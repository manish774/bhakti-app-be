/* tslint:disable */
/* eslint-disable */
/**
 * Bhakti App API
 * Comprehensive API documentation for Bhakti App - A spiritual services booking platform
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@bhaktiapp.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface Answer {
    '_id'?: string;
    'answer'?: string;
    'dateTime'?: string;
    'groupId'?: string;
    'answeredBy'?: string;
    'status'?: string;
    'isActive'?: AnswerIsActiveEnum;
    'createdAt'?: string;
    'updatedAt'?: string;
}

export const AnswerIsActiveEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type AnswerIsActiveEnum = typeof AnswerIsActiveEnum[keyof typeof AnswerIsActiveEnum];

export interface ApiAuthLoginPost200Response {
    'userdetail'?: User;
    /**
     * JWT token
     */
    'token'?: string;
}
export interface ApiAuthLoginPost400Response {
    'message'?: string;
}
export interface ApiAuthLoginPostRequest {
    'email': string;
    'password': string;
}
export interface ApiAuthResendOtpPost200Response {
    'success'?: boolean;
    'message'?: string;
}
export interface ApiAuthResendOtpPostRequest {
    'email': string;
}
export interface ApiAuthSignupPostRequest {
    'name': string;
    'email': string;
    'password': string;
}
export interface ApiAuthVerifyOtpPost200Response {
    'success'?: boolean;
    'message'?: string;
}
export interface ApiAuthVerifyOtpPostRequest {
    'email': string;
    'otp': string;
}
export interface ApiCoreeventCreatePostRequest {
    'type': ApiCoreeventCreatePostRequestTypeEnum;
    'title': string;
    'description'?: string;
    'icon': string;
    'color'?: string;
    'shadowColor'?: string;
    'visible'?: boolean;
}

export const ApiCoreeventCreatePostRequestTypeEnum = {
    CoreeventOnlinePuja: 'coreevent_online_puja',
    CoreeventOfflinePuja: 'coreevent_offline_puja'
} as const;

export type ApiCoreeventCreatePostRequestTypeEnum = typeof ApiCoreeventCreatePostRequestTypeEnum[keyof typeof ApiCoreeventCreatePostRequestTypeEnum];

export interface ApiCoreeventGetByTypesPostRequest {
    /**
     * Array of core event types
     */
    'types': Array<ApiCoreeventGetByTypesPostRequestTypesEnum>;
}

export const ApiCoreeventGetByTypesPostRequestTypesEnum = {
    CoreeventOnlinePuja: 'coreevent_online_puja',
    CoreeventOfflinePuja: 'coreevent_offline_puja'
} as const;

export type ApiCoreeventGetByTypesPostRequestTypesEnum = typeof ApiCoreeventGetByTypesPostRequestTypesEnum[keyof typeof ApiCoreeventGetByTypesPostRequestTypesEnum];

export interface ApiCoreeventGetGet200Response {
    'data'?: Array<CoreEvent>;
    'pagination'?: Pagination;
}
export interface ApiCoreeventUpdatePatchRequest {
    /**
     * Core event type (used to identify the event)
     */
    'type': ApiCoreeventUpdatePatchRequestTypeEnum;
    'title'?: string;
    'description'?: string;
    'icon'?: string;
    'color'?: string;
    'shadowColor'?: string;
    'visible'?: boolean;
}

export const ApiCoreeventUpdatePatchRequestTypeEnum = {
    CoreeventOnlinePuja: 'coreevent_online_puja',
    CoreeventOfflinePuja: 'coreevent_offline_puja'
} as const;

export type ApiCoreeventUpdatePatchRequestTypeEnum = typeof ApiCoreeventUpdatePatchRequestTypeEnum[keyof typeof ApiCoreeventUpdatePatchRequestTypeEnum];

export interface ApiEventCreatePostRequest {
    'coreEventId': string;
    'eventName': string;
    'templeId': Array<string>;
    'packageId': Array<string>;
    'pricePackageId': Array<ApiEventCreatePostRequestPricePackageIdInner>;
    'eventStartTime': string;
    'eventExpirationTime': string;
    'isPopular'?: boolean;
}
export interface ApiEventCreatePostRequestPricePackageIdInner {
    'packageId'?: string;
    'price'?: number;
    'discount'?: number;
}
export interface ApiEventDeleteDeleteRequest {
    /**
     * Event ID to delete
     */
    'id': string;
}
export interface ApiEventGetGet200Response {
    'data'?: Array<Event>;
    'pagination'?: Pagination;
}
export interface ApiEventUpdatePatchRequest {
    /**
     * Event ID
     */
    'id': string;
    'coreEventId'?: string;
    'eventName'?: string;
    'templeId'?: Array<string>;
    'packageId'?: Array<string>;
    'pricePackageId'?: Array<object>;
    'eventStartTime'?: string;
    'eventExpirationTime'?: string;
    'isPopular'?: boolean;
}
export interface ApiGameStartPost200Response {
    'answers'?: Array<Answer>;
    'questions'?: Array<Question>;
}
export interface ApiGameStartPostRequest {
    /**
     * Group ID
     */
    'groupId': string;
    /**
     * Date and time for the game session
     */
    'dateTime': string;
}
export interface ApiPackageCreatePostRequest {
    'name': string;
    'numberOfPerson': number;
    'title'?: string;
    'price': number;
    'description'?: Array<ApiPackageCreatePostRequestDescriptionInner>;
    'isPopular'?: boolean;
}
export interface ApiPackageCreatePostRequestDescriptionInner {
    'id'?: number;
    'detail'?: string;
}
export interface ApiPackageDeleteDeleteRequest {
    /**
     * Package ID to delete
     */
    'id': string;
}
export interface ApiPackageGetByIdsPostRequest {
    /**
     * Array of package IDs
     */
    'ids': Array<string>;
}
export interface ApiPackageGetGet200Response {
    'data'?: Array<Package>;
    'pagination'?: Pagination;
}
export interface ApiPackageUpdatePatchRequest {
    /**
     * Package ID
     */
    'id': string;
    'name'?: string;
    'numberOfPerson'?: number;
    'title'?: string;
    'price'?: number;
    'description'?: Array<object>;
    'isPopular'?: boolean;
}
export interface ApiPanditCreatePostRequest {
    'name': string;
    'about': string;
    'address': string;
    'email'?: string;
    'phone': string;
    'extraInfo'?: string;
    'specialization': Array<string>;
    'templeAssociatedId': Array<string>;
}
export interface ApiPanditDeleteDeleteRequest {
    /**
     * Pandit ID to delete
     */
    'id': string;
}
export interface ApiPanditUpdatePatchRequest {
    /**
     * Pandit ID
     */
    'id': string;
    'name'?: string;
    'about'?: string;
    'address'?: string;
    'email'?: string;
    'phone'?: string;
    'extraInfo'?: string;
    'specialization'?: Array<string>;
    'templeAssociatedId'?: Array<string>;
}
export interface ApiProfileProfileUserIdPatchRequest {
    'name'?: string;
    'email'?: string;
}
export interface ApiUploadMultiplePost200Response {
    'message'?: string;
    'files'?: Array<ApiUploadSinglePost200ResponseFile>;
}
export interface ApiUploadSinglePost200Response {
    'message'?: string;
    'file'?: ApiUploadSinglePost200ResponseFile;
}
export interface ApiUploadSinglePost200ResponseFile {
    'filename'?: string;
    'url'?: string;
}
export interface Booking {
    '_id'?: string;
    'coreType'?: string;
    'eventId'?: string;
    'userId'?: string;
    'templeId'?: string;
    'packageId'?: string;
    'devotees'?: Array<BookingDevoteesInner>;
    'totalAmount'?: number;
    'prasadIncluded'?: boolean;
    'prasadCharge'?: number;
    'bookingDate'?: string;
    'pujaDate'?: string;
    'status'?: BookingStatusEnum;
    'paymentStatus'?: BookingPaymentStatusEnum;
    'paymentId'?: string;
    'videoUrl'?: string;
    'videoUploadedAt'?: string;
    'notes'?: string;
    'createdAt'?: string;
    'updatedAt'?: string;
}

export const BookingStatusEnum = {
    Pending: 'pending',
    Confirmed: 'confirmed',
    Completed: 'completed',
    Cancelled: 'cancelled'
} as const;

export type BookingStatusEnum = typeof BookingStatusEnum[keyof typeof BookingStatusEnum];
export const BookingPaymentStatusEnum = {
    Pending: 'pending',
    Paid: 'paid',
    Failed: 'failed',
    Refunded: 'refunded'
} as const;

export type BookingPaymentStatusEnum = typeof BookingPaymentStatusEnum[keyof typeof BookingPaymentStatusEnum];

export interface BookingDevoteesInner {
    'name'?: string;
    'gotra'?: string;
    'phoneNumber'?: string;
    'email'?: string;
}
export interface CoreEvent {
    '_id'?: string;
    'type'?: CoreEventTypeEnum;
    'title'?: string;
    'description'?: string;
    'icon'?: string;
    'color'?: string;
    'shadowColor'?: string;
    'visible'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
}

export const CoreEventTypeEnum = {
    CoreeventOnlinePuja: 'coreevent_online_puja',
    CoreeventOfflinePuja: 'coreevent_offline_puja'
} as const;

export type CoreEventTypeEnum = typeof CoreEventTypeEnum[keyof typeof CoreEventTypeEnum];

export interface Event {
    '_id'?: string;
    'coreEventId'?: string;
    'eventName'?: string;
    'templeId'?: Array<string>;
    'packageId'?: Array<string>;
    'pricePackageId'?: Array<ApiEventCreatePostRequestPricePackageIdInner>;
    'eventStartTime'?: string;
    'eventExpirationTime'?: string;
    'isPopular'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface Group {
    '_id'?: string;
    'name'?: string;
    'type'?: GroupTypeEnum;
    'adminIds'?: Array<string>;
    'memberIds'?: Array<string>;
    'createdAt'?: string;
    'updatedAt'?: string;
}

export const GroupTypeEnum = {
    Private: 'PRIVATE',
    Public: 'PUBLIC'
} as const;

export type GroupTypeEnum = typeof GroupTypeEnum[keyof typeof GroupTypeEnum];

export interface HealthGet200Response {
    'status'?: string;
    'timestamp'?: string;
    /**
     * Server uptime in seconds
     */
    'uptime'?: number;
    'environment'?: string;
}
export interface Location {
    'addressLine1': string;
    'addressLine2'?: string;
    'landmark'?: string;
    'city': string;
    'state': string;
    'country': string;
    'pinCode': string;
}
export interface ModelError {
    /**
     * Error message
     */
    'message'?: string;
    /**
     * Validation errors
     */
    'errors'?: object;
}
export interface Package {
    '_id'?: string;
    'name'?: string;
    'numberOfPerson'?: number;
    'title'?: string;
    'price'?: number;
    'description'?: Array<ApiPackageCreatePostRequestDescriptionInner>;
    'isPopular'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface Pagination {
    /**
     * Total number of items
     */
    'total'?: number;
    /**
     * Current page number
     */
    'page'?: number;
    /**
     * Items per page
     */
    'limit'?: number;
    /**
     * Total number of pages
     */
    'totalPages'?: number;
}
export interface Pandit {
    '_id'?: string;
    'name'?: string;
    'about'?: string;
    'address'?: string;
    'email'?: string;
    'phone'?: string;
    'extraInfo'?: string;
    'specialization'?: Array<string>;
    'templeAssociatedId'?: Array<string>;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface Puja {
    '_id'?: string;
    'coreId'?: string;
    'className'?: string;
    'name'?: string;
    'startPrice'?: number;
    'description'?: Array<PujaDescriptionInner>;
    'pujaDescription'?: object;
    'benefits'?: Array<PujaBenefitsInner>;
    'templeId'?: string;
    'metaData'?: object;
    'isActive'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface PujaBenefitsInner {
    'name'?: string;
    'benifit'?: string;
}
export interface PujaDescriptionInner {
    'description'?: string;
}
export interface Question {
    '_id'?: string;
    'question'?: string;
    'dateTime'?: string;
    'groupId'?: string;
    'askedBy'?: string;
    'status'?: string;
    'isActive'?: QuestionIsActiveEnum;
    'createdAt'?: string;
    'updatedAt'?: string;
}

export const QuestionIsActiveEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type QuestionIsActiveEnum = typeof QuestionIsActiveEnum[keyof typeof QuestionIsActiveEnum];

export interface SuccessResponse {
    'success'?: boolean;
    'message'?: string;
    'data'?: object;
}
export interface Temple {
    '_id'?: string;
    'name'?: string;
    'location'?: Location;
    'image'?: string;
    'images'?: Array<string>;
    'description'?: Array<string>;
    'extraInfo'?: object;
    'contractorInfo'?: TempleContractorInfo;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface TempleContractorInfo {
    'name'?: string;
    'phone'?: string;
    'address'?: Location;
}
export interface User {
    '_id'?: string;
    'name'?: string;
    'email'?: string;
    'role'?: UserRoleEnum;
    'isActive'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
}

export const UserRoleEnum = {
    User: 'user',
    Admin: 'admin'
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];


/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary User login
         * @param {ApiAuthLoginPostRequest} apiAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthLoginPost: async (apiAuthLoginPostRequest: ApiAuthLoginPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiAuthLoginPostRequest' is not null or undefined
            assertParamExists('apiAuthLoginPost', 'apiAuthLoginPostRequest', apiAuthLoginPostRequest)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiAuthLoginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthLogoutGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resend OTP verification code
         * @param {ApiAuthResendOtpPostRequest} apiAuthResendOtpPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthResendOtpPost: async (apiAuthResendOtpPostRequest: ApiAuthResendOtpPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiAuthResendOtpPostRequest' is not null or undefined
            assertParamExists('apiAuthResendOtpPost', 'apiAuthResendOtpPostRequest', apiAuthResendOtpPostRequest)
            const localVarPath = `/api/auth/resendOtp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiAuthResendOtpPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User registration
         * @param {ApiAuthSignupPostRequest} apiAuthSignupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthSignupPost: async (apiAuthSignupPostRequest: ApiAuthSignupPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiAuthSignupPostRequest' is not null or undefined
            assertParamExists('apiAuthSignupPost', 'apiAuthSignupPostRequest', apiAuthSignupPostRequest)
            const localVarPath = `/api/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiAuthSignupPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify OTP and activate account
         * @param {ApiAuthVerifyOtpPostRequest} apiAuthVerifyOtpPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthVerifyOtpPost: async (apiAuthVerifyOtpPostRequest: ApiAuthVerifyOtpPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiAuthVerifyOtpPostRequest' is not null or undefined
            assertParamExists('apiAuthVerifyOtpPost', 'apiAuthVerifyOtpPostRequest', apiAuthVerifyOtpPostRequest)
            const localVarPath = `/api/auth/verify-otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiAuthVerifyOtpPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary User login
         * @param {ApiAuthLoginPostRequest} apiAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthLoginPost(apiAuthLoginPostRequest: ApiAuthLoginPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAuthLoginPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthLoginPost(apiAuthLoginPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.apiAuthLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthLogoutGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthLogoutGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.apiAuthLogoutGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Resend OTP verification code
         * @param {ApiAuthResendOtpPostRequest} apiAuthResendOtpPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthResendOtpPost(apiAuthResendOtpPostRequest: ApiAuthResendOtpPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAuthResendOtpPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthResendOtpPost(apiAuthResendOtpPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.apiAuthResendOtpPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User registration
         * @param {ApiAuthSignupPostRequest} apiAuthSignupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthSignupPost(apiAuthSignupPostRequest: ApiAuthSignupPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthSignupPost(apiAuthSignupPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.apiAuthSignupPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify OTP and activate account
         * @param {ApiAuthVerifyOtpPostRequest} apiAuthVerifyOtpPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthVerifyOtpPost(apiAuthVerifyOtpPostRequest: ApiAuthVerifyOtpPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAuthVerifyOtpPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthVerifyOtpPost(apiAuthVerifyOtpPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.apiAuthVerifyOtpPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary User login
         * @param {ApiAuthLoginPostRequest} apiAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthLoginPost(apiAuthLoginPostRequest: ApiAuthLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiAuthLoginPost200Response> {
            return localVarFp.apiAuthLoginPost(apiAuthLoginPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthLogoutGet(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.apiAuthLogoutGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resend OTP verification code
         * @param {ApiAuthResendOtpPostRequest} apiAuthResendOtpPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthResendOtpPost(apiAuthResendOtpPostRequest: ApiAuthResendOtpPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiAuthResendOtpPost200Response> {
            return localVarFp.apiAuthResendOtpPost(apiAuthResendOtpPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User registration
         * @param {ApiAuthSignupPostRequest} apiAuthSignupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthSignupPost(apiAuthSignupPostRequest: ApiAuthSignupPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.apiAuthSignupPost(apiAuthSignupPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify OTP and activate account
         * @param {ApiAuthVerifyOtpPostRequest} apiAuthVerifyOtpPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthVerifyOtpPost(apiAuthVerifyOtpPostRequest: ApiAuthVerifyOtpPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiAuthVerifyOtpPost200Response> {
            return localVarFp.apiAuthVerifyOtpPost(apiAuthVerifyOtpPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary User login
     * @param {ApiAuthLoginPostRequest} apiAuthLoginPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiAuthLoginPost(apiAuthLoginPostRequest: ApiAuthLoginPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthLoginPost(apiAuthLoginPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiAuthLogoutGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthLogoutGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resend OTP verification code
     * @param {ApiAuthResendOtpPostRequest} apiAuthResendOtpPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiAuthResendOtpPost(apiAuthResendOtpPostRequest: ApiAuthResendOtpPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthResendOtpPost(apiAuthResendOtpPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User registration
     * @param {ApiAuthSignupPostRequest} apiAuthSignupPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiAuthSignupPost(apiAuthSignupPostRequest: ApiAuthSignupPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthSignupPost(apiAuthSignupPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify OTP and activate account
     * @param {ApiAuthVerifyOtpPostRequest} apiAuthVerifyOtpPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiAuthVerifyOtpPost(apiAuthVerifyOtpPostRequest: ApiAuthVerifyOtpPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthVerifyOtpPost(apiAuthVerifyOtpPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CoreEventsApi - axios parameter creator
 */
export const CoreEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new core event
         * @param {ApiCoreeventCreatePostRequest} apiCoreeventCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCoreeventCreatePost: async (apiCoreeventCreatePostRequest: ApiCoreeventCreatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiCoreeventCreatePostRequest' is not null or undefined
            assertParamExists('apiCoreeventCreatePost', 'apiCoreeventCreatePostRequest', apiCoreeventCreatePostRequest)
            const localVarPath = `/api/coreevent/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiCoreeventCreatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get core events by types
         * @param {ApiCoreeventGetByTypesPostRequest} apiCoreeventGetByTypesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCoreeventGetByTypesPost: async (apiCoreeventGetByTypesPostRequest: ApiCoreeventGetByTypesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiCoreeventGetByTypesPostRequest' is not null or undefined
            assertParamExists('apiCoreeventGetByTypesPost', 'apiCoreeventGetByTypesPostRequest', apiCoreeventGetByTypesPostRequest)
            const localVarPath = `/api/coreevent/getByTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiCoreeventGetByTypesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all core events with pagination
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCoreeventGetGet: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/coreevent/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a core event
         * @param {ApiCoreeventUpdatePatchRequest} apiCoreeventUpdatePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCoreeventUpdatePatch: async (apiCoreeventUpdatePatchRequest: ApiCoreeventUpdatePatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiCoreeventUpdatePatchRequest' is not null or undefined
            assertParamExists('apiCoreeventUpdatePatch', 'apiCoreeventUpdatePatchRequest', apiCoreeventUpdatePatchRequest)
            const localVarPath = `/api/coreevent/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiCoreeventUpdatePatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoreEventsApi - functional programming interface
 */
export const CoreEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoreEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new core event
         * @param {ApiCoreeventCreatePostRequest} apiCoreeventCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCoreeventCreatePost(apiCoreeventCreatePostRequest: ApiCoreeventCreatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoreEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCoreeventCreatePost(apiCoreeventCreatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreEventsApi.apiCoreeventCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get core events by types
         * @param {ApiCoreeventGetByTypesPostRequest} apiCoreeventGetByTypesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCoreeventGetByTypesPost(apiCoreeventGetByTypesPostRequest: ApiCoreeventGetByTypesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CoreEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCoreeventGetByTypesPost(apiCoreeventGetByTypesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreEventsApi.apiCoreeventGetByTypesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all core events with pagination
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCoreeventGetGet(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCoreeventGetGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCoreeventGetGet(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreEventsApi.apiCoreeventGetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a core event
         * @param {ApiCoreeventUpdatePatchRequest} apiCoreeventUpdatePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCoreeventUpdatePatch(apiCoreeventUpdatePatchRequest: ApiCoreeventUpdatePatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoreEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCoreeventUpdatePatch(apiCoreeventUpdatePatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreEventsApi.apiCoreeventUpdatePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CoreEventsApi - factory interface
 */
export const CoreEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoreEventsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new core event
         * @param {ApiCoreeventCreatePostRequest} apiCoreeventCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCoreeventCreatePost(apiCoreeventCreatePostRequest: ApiCoreeventCreatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<CoreEvent> {
            return localVarFp.apiCoreeventCreatePost(apiCoreeventCreatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get core events by types
         * @param {ApiCoreeventGetByTypesPostRequest} apiCoreeventGetByTypesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCoreeventGetByTypesPost(apiCoreeventGetByTypesPostRequest: ApiCoreeventGetByTypesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CoreEvent>> {
            return localVarFp.apiCoreeventGetByTypesPost(apiCoreeventGetByTypesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all core events with pagination
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCoreeventGetGet(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiCoreeventGetGet200Response> {
            return localVarFp.apiCoreeventGetGet(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a core event
         * @param {ApiCoreeventUpdatePatchRequest} apiCoreeventUpdatePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCoreeventUpdatePatch(apiCoreeventUpdatePatchRequest: ApiCoreeventUpdatePatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<CoreEvent> {
            return localVarFp.apiCoreeventUpdatePatch(apiCoreeventUpdatePatchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoreEventsApi - object-oriented interface
 */
export class CoreEventsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new core event
     * @param {ApiCoreeventCreatePostRequest} apiCoreeventCreatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiCoreeventCreatePost(apiCoreeventCreatePostRequest: ApiCoreeventCreatePostRequest, options?: RawAxiosRequestConfig) {
        return CoreEventsApiFp(this.configuration).apiCoreeventCreatePost(apiCoreeventCreatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get core events by types
     * @param {ApiCoreeventGetByTypesPostRequest} apiCoreeventGetByTypesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiCoreeventGetByTypesPost(apiCoreeventGetByTypesPostRequest: ApiCoreeventGetByTypesPostRequest, options?: RawAxiosRequestConfig) {
        return CoreEventsApiFp(this.configuration).apiCoreeventGetByTypesPost(apiCoreeventGetByTypesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all core events with pagination
     * @param {number} [page] Page number
     * @param {number} [limit] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiCoreeventGetGet(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return CoreEventsApiFp(this.configuration).apiCoreeventGetGet(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a core event
     * @param {ApiCoreeventUpdatePatchRequest} apiCoreeventUpdatePatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiCoreeventUpdatePatch(apiCoreeventUpdatePatchRequest: ApiCoreeventUpdatePatchRequest, options?: RawAxiosRequestConfig) {
        return CoreEventsApiFp(this.configuration).apiCoreeventUpdatePatch(apiCoreeventUpdatePatchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventsApi - axios parameter creator
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new event
         * @param {ApiEventCreatePostRequest} apiEventCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventCreatePost: async (apiEventCreatePostRequest: ApiEventCreatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiEventCreatePostRequest' is not null or undefined
            assertParamExists('apiEventCreatePost', 'apiEventCreatePostRequest', apiEventCreatePostRequest)
            const localVarPath = `/api/event/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiEventCreatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an event
         * @param {ApiEventDeleteDeleteRequest} apiEventDeleteDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventDeleteDelete: async (apiEventDeleteDeleteRequest: ApiEventDeleteDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiEventDeleteDeleteRequest' is not null or undefined
            assertParamExists('apiEventDeleteDelete', 'apiEventDeleteDeleteRequest', apiEventDeleteDeleteRequest)
            const localVarPath = `/api/event/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiEventDeleteDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all events with pagination and filters
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {string} [templeId] Filter by temple ID
         * @param {string} [coreEventId] Filter by core event ID
         * @param {string} [packageId] Filter by package ID
         * @param {boolean} [isPopular] Filter by popular status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventGetGet: async (page?: number, limit?: number, templeId?: string, coreEventId?: string, packageId?: string, isPopular?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/event/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (templeId !== undefined) {
                localVarQueryParameter['templeId'] = templeId;
            }

            if (coreEventId !== undefined) {
                localVarQueryParameter['coreEventId'] = coreEventId;
            }

            if (packageId !== undefined) {
                localVarQueryParameter['packageId'] = packageId;
            }

            if (isPopular !== undefined) {
                localVarQueryParameter['isPopular'] = isPopular;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get events by temple ID
         * @param {string} templeId Temple ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventGetbytempleGet: async (templeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templeId' is not null or undefined
            assertParamExists('apiEventGetbytempleGet', 'templeId', templeId)
            const localVarPath = `/api/event/getbytemple`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (templeId !== undefined) {
                localVarQueryParameter['templeId'] = templeId;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an event
         * @param {ApiEventUpdatePatchRequest} apiEventUpdatePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventUpdatePatch: async (apiEventUpdatePatchRequest: ApiEventUpdatePatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiEventUpdatePatchRequest' is not null or undefined
            assertParamExists('apiEventUpdatePatch', 'apiEventUpdatePatchRequest', apiEventUpdatePatchRequest)
            const localVarPath = `/api/event/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiEventUpdatePatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new event
         * @param {ApiEventCreatePostRequest} apiEventCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiEventCreatePost(apiEventCreatePostRequest: ApiEventCreatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiEventCreatePost(apiEventCreatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.apiEventCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an event
         * @param {ApiEventDeleteDeleteRequest} apiEventDeleteDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiEventDeleteDelete(apiEventDeleteDeleteRequest: ApiEventDeleteDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiEventDeleteDelete(apiEventDeleteDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.apiEventDeleteDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all events with pagination and filters
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {string} [templeId] Filter by temple ID
         * @param {string} [coreEventId] Filter by core event ID
         * @param {string} [packageId] Filter by package ID
         * @param {boolean} [isPopular] Filter by popular status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiEventGetGet(page?: number, limit?: number, templeId?: string, coreEventId?: string, packageId?: string, isPopular?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiEventGetGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiEventGetGet(page, limit, templeId, coreEventId, packageId, isPopular, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.apiEventGetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get events by temple ID
         * @param {string} templeId Temple ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiEventGetbytempleGet(templeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiEventGetbytempleGet(templeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.apiEventGetbytempleGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an event
         * @param {ApiEventUpdatePatchRequest} apiEventUpdatePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiEventUpdatePatch(apiEventUpdatePatchRequest: ApiEventUpdatePatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiEventUpdatePatch(apiEventUpdatePatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.apiEventUpdatePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventsApi - factory interface
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new event
         * @param {ApiEventCreatePostRequest} apiEventCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventCreatePost(apiEventCreatePostRequest: ApiEventCreatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.apiEventCreatePost(apiEventCreatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an event
         * @param {ApiEventDeleteDeleteRequest} apiEventDeleteDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventDeleteDelete(apiEventDeleteDeleteRequest: ApiEventDeleteDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.apiEventDeleteDelete(apiEventDeleteDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all events with pagination and filters
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {string} [templeId] Filter by temple ID
         * @param {string} [coreEventId] Filter by core event ID
         * @param {string} [packageId] Filter by package ID
         * @param {boolean} [isPopular] Filter by popular status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventGetGet(page?: number, limit?: number, templeId?: string, coreEventId?: string, packageId?: string, isPopular?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ApiEventGetGet200Response> {
            return localVarFp.apiEventGetGet(page, limit, templeId, coreEventId, packageId, isPopular, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get events by temple ID
         * @param {string} templeId Temple ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventGetbytempleGet(templeId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Event>> {
            return localVarFp.apiEventGetbytempleGet(templeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an event
         * @param {ApiEventUpdatePatchRequest} apiEventUpdatePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEventUpdatePatch(apiEventUpdatePatchRequest: ApiEventUpdatePatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.apiEventUpdatePatch(apiEventUpdatePatchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 */
export class EventsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new event
     * @param {ApiEventCreatePostRequest} apiEventCreatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiEventCreatePost(apiEventCreatePostRequest: ApiEventCreatePostRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).apiEventCreatePost(apiEventCreatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an event
     * @param {ApiEventDeleteDeleteRequest} apiEventDeleteDeleteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiEventDeleteDelete(apiEventDeleteDeleteRequest: ApiEventDeleteDeleteRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).apiEventDeleteDelete(apiEventDeleteDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all events with pagination and filters
     * @param {number} [page] Page number
     * @param {number} [limit] Items per page
     * @param {string} [templeId] Filter by temple ID
     * @param {string} [coreEventId] Filter by core event ID
     * @param {string} [packageId] Filter by package ID
     * @param {boolean} [isPopular] Filter by popular status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiEventGetGet(page?: number, limit?: number, templeId?: string, coreEventId?: string, packageId?: string, isPopular?: boolean, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).apiEventGetGet(page, limit, templeId, coreEventId, packageId, isPopular, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get events by temple ID
     * @param {string} templeId Temple ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiEventGetbytempleGet(templeId: string, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).apiEventGetbytempleGet(templeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an event
     * @param {ApiEventUpdatePatchRequest} apiEventUpdatePatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiEventUpdatePatch(apiEventUpdatePatchRequest: ApiEventUpdatePatchRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).apiEventUpdatePatch(apiEventUpdatePatchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GameApi - axios parameter creator
 */
export const GameApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Start a game session
         * @param {ApiGameStartPostRequest} apiGameStartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGameStartPost: async (apiGameStartPostRequest: ApiGameStartPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiGameStartPostRequest' is not null or undefined
            assertParamExists('apiGameStartPost', 'apiGameStartPostRequest', apiGameStartPostRequest)
            const localVarPath = `/api/game/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiGameStartPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GameApi - functional programming interface
 */
export const GameApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GameApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Start a game session
         * @param {ApiGameStartPostRequest} apiGameStartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGameStartPost(apiGameStartPostRequest: ApiGameStartPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiGameStartPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGameStartPost(apiGameStartPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.apiGameStartPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GameApi - factory interface
 */
export const GameApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GameApiFp(configuration)
    return {
        /**
         * 
         * @summary Start a game session
         * @param {ApiGameStartPostRequest} apiGameStartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGameStartPost(apiGameStartPostRequest: ApiGameStartPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiGameStartPost200Response> {
            return localVarFp.apiGameStartPost(apiGameStartPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GameApi - object-oriented interface
 */
export class GameApi extends BaseAPI {
    /**
     * 
     * @summary Start a game session
     * @param {ApiGameStartPostRequest} apiGameStartPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiGameStartPost(apiGameStartPostRequest: ApiGameStartPostRequest, options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).apiGameStartPost(apiGameStartPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet(options?: RawAxiosRequestConfig): AxiosPromise<HealthGet200Response> {
            return localVarFp.healthGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthGet(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PackagesApi - axios parameter creator
 */
export const PackagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new package
         * @param {ApiPackageCreatePostRequest} apiPackageCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPackageCreatePost: async (apiPackageCreatePostRequest: ApiPackageCreatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiPackageCreatePostRequest' is not null or undefined
            assertParamExists('apiPackageCreatePost', 'apiPackageCreatePostRequest', apiPackageCreatePostRequest)
            const localVarPath = `/api/package/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiPackageCreatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a package
         * @param {ApiPackageDeleteDeleteRequest} apiPackageDeleteDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPackageDeleteDelete: async (apiPackageDeleteDeleteRequest: ApiPackageDeleteDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiPackageDeleteDeleteRequest' is not null or undefined
            assertParamExists('apiPackageDeleteDelete', 'apiPackageDeleteDeleteRequest', apiPackageDeleteDeleteRequest)
            const localVarPath = `/api/package/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiPackageDeleteDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get packages by IDs
         * @param {ApiPackageGetByIdsPostRequest} apiPackageGetByIdsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPackageGetByIdsPost: async (apiPackageGetByIdsPostRequest: ApiPackageGetByIdsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiPackageGetByIdsPostRequest' is not null or undefined
            assertParamExists('apiPackageGetByIdsPost', 'apiPackageGetByIdsPostRequest', apiPackageGetByIdsPostRequest)
            const localVarPath = `/api/package/getByIds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiPackageGetByIdsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all packages with pagination
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPackageGetGet: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/package/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a package
         * @param {ApiPackageUpdatePatchRequest} apiPackageUpdatePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPackageUpdatePatch: async (apiPackageUpdatePatchRequest: ApiPackageUpdatePatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiPackageUpdatePatchRequest' is not null or undefined
            assertParamExists('apiPackageUpdatePatch', 'apiPackageUpdatePatchRequest', apiPackageUpdatePatchRequest)
            const localVarPath = `/api/package/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiPackageUpdatePatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PackagesApi - functional programming interface
 */
export const PackagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PackagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new package
         * @param {ApiPackageCreatePostRequest} apiPackageCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPackageCreatePost(apiPackageCreatePostRequest: ApiPackageCreatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Package>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPackageCreatePost(apiPackageCreatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackagesApi.apiPackageCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a package
         * @param {ApiPackageDeleteDeleteRequest} apiPackageDeleteDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPackageDeleteDelete(apiPackageDeleteDeleteRequest: ApiPackageDeleteDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Package>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPackageDeleteDelete(apiPackageDeleteDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackagesApi.apiPackageDeleteDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get packages by IDs
         * @param {ApiPackageGetByIdsPostRequest} apiPackageGetByIdsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPackageGetByIdsPost(apiPackageGetByIdsPostRequest: ApiPackageGetByIdsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Package>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPackageGetByIdsPost(apiPackageGetByIdsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackagesApi.apiPackageGetByIdsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all packages with pagination
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPackageGetGet(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiPackageGetGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPackageGetGet(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackagesApi.apiPackageGetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a package
         * @param {ApiPackageUpdatePatchRequest} apiPackageUpdatePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPackageUpdatePatch(apiPackageUpdatePatchRequest: ApiPackageUpdatePatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Package>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPackageUpdatePatch(apiPackageUpdatePatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackagesApi.apiPackageUpdatePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PackagesApi - factory interface
 */
export const PackagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PackagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new package
         * @param {ApiPackageCreatePostRequest} apiPackageCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPackageCreatePost(apiPackageCreatePostRequest: ApiPackageCreatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Package> {
            return localVarFp.apiPackageCreatePost(apiPackageCreatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a package
         * @param {ApiPackageDeleteDeleteRequest} apiPackageDeleteDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPackageDeleteDelete(apiPackageDeleteDeleteRequest: ApiPackageDeleteDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<Package> {
            return localVarFp.apiPackageDeleteDelete(apiPackageDeleteDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get packages by IDs
         * @param {ApiPackageGetByIdsPostRequest} apiPackageGetByIdsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPackageGetByIdsPost(apiPackageGetByIdsPostRequest: ApiPackageGetByIdsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Package>> {
            return localVarFp.apiPackageGetByIdsPost(apiPackageGetByIdsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all packages with pagination
         * @param {number} [page] Page number
         * @param {number} [limit] Items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPackageGetGet(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiPackageGetGet200Response> {
            return localVarFp.apiPackageGetGet(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a package
         * @param {ApiPackageUpdatePatchRequest} apiPackageUpdatePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPackageUpdatePatch(apiPackageUpdatePatchRequest: ApiPackageUpdatePatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<Package> {
            return localVarFp.apiPackageUpdatePatch(apiPackageUpdatePatchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PackagesApi - object-oriented interface
 */
export class PackagesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new package
     * @param {ApiPackageCreatePostRequest} apiPackageCreatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiPackageCreatePost(apiPackageCreatePostRequest: ApiPackageCreatePostRequest, options?: RawAxiosRequestConfig) {
        return PackagesApiFp(this.configuration).apiPackageCreatePost(apiPackageCreatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a package
     * @param {ApiPackageDeleteDeleteRequest} apiPackageDeleteDeleteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiPackageDeleteDelete(apiPackageDeleteDeleteRequest: ApiPackageDeleteDeleteRequest, options?: RawAxiosRequestConfig) {
        return PackagesApiFp(this.configuration).apiPackageDeleteDelete(apiPackageDeleteDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get packages by IDs
     * @param {ApiPackageGetByIdsPostRequest} apiPackageGetByIdsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiPackageGetByIdsPost(apiPackageGetByIdsPostRequest: ApiPackageGetByIdsPostRequest, options?: RawAxiosRequestConfig) {
        return PackagesApiFp(this.configuration).apiPackageGetByIdsPost(apiPackageGetByIdsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all packages with pagination
     * @param {number} [page] Page number
     * @param {number} [limit] Items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiPackageGetGet(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return PackagesApiFp(this.configuration).apiPackageGetGet(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a package
     * @param {ApiPackageUpdatePatchRequest} apiPackageUpdatePatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiPackageUpdatePatch(apiPackageUpdatePatchRequest: ApiPackageUpdatePatchRequest, options?: RawAxiosRequestConfig) {
        return PackagesApiFp(this.configuration).apiPackageUpdatePatch(apiPackageUpdatePatchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PanditsApi - axios parameter creator
 */
export const PanditsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new pandit
         * @param {ApiPanditCreatePostRequest} apiPanditCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPanditCreatePost: async (apiPanditCreatePostRequest: ApiPanditCreatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiPanditCreatePostRequest' is not null or undefined
            assertParamExists('apiPanditCreatePost', 'apiPanditCreatePostRequest', apiPanditCreatePostRequest)
            const localVarPath = `/api/pandit/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiPanditCreatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a pandit
         * @param {ApiPanditDeleteDeleteRequest} apiPanditDeleteDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPanditDeleteDelete: async (apiPanditDeleteDeleteRequest: ApiPanditDeleteDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiPanditDeleteDeleteRequest' is not null or undefined
            assertParamExists('apiPanditDeleteDelete', 'apiPanditDeleteDeleteRequest', apiPanditDeleteDeleteRequest)
            const localVarPath = `/api/pandit/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiPanditDeleteDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all pandits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPanditGetGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pandit/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get pandits by temple ID
         * @param {string} templeId Temple ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPanditGetbytempleGet: async (templeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templeId' is not null or undefined
            assertParamExists('apiPanditGetbytempleGet', 'templeId', templeId)
            const localVarPath = `/api/pandit/getbytemple`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (templeId !== undefined) {
                localVarQueryParameter['templeId'] = templeId;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a pandit
         * @param {ApiPanditUpdatePatchRequest} apiPanditUpdatePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPanditUpdatePatch: async (apiPanditUpdatePatchRequest: ApiPanditUpdatePatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiPanditUpdatePatchRequest' is not null or undefined
            assertParamExists('apiPanditUpdatePatch', 'apiPanditUpdatePatchRequest', apiPanditUpdatePatchRequest)
            const localVarPath = `/api/pandit/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiPanditUpdatePatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PanditsApi - functional programming interface
 */
export const PanditsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PanditsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new pandit
         * @param {ApiPanditCreatePostRequest} apiPanditCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPanditCreatePost(apiPanditCreatePostRequest: ApiPanditCreatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pandit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPanditCreatePost(apiPanditCreatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PanditsApi.apiPanditCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a pandit
         * @param {ApiPanditDeleteDeleteRequest} apiPanditDeleteDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPanditDeleteDelete(apiPanditDeleteDeleteRequest: ApiPanditDeleteDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pandit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPanditDeleteDelete(apiPanditDeleteDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PanditsApi.apiPanditDeleteDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all pandits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPanditGetGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pandit>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPanditGetGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PanditsApi.apiPanditGetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get pandits by temple ID
         * @param {string} templeId Temple ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPanditGetbytempleGet(templeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pandit>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPanditGetbytempleGet(templeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PanditsApi.apiPanditGetbytempleGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a pandit
         * @param {ApiPanditUpdatePatchRequest} apiPanditUpdatePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPanditUpdatePatch(apiPanditUpdatePatchRequest: ApiPanditUpdatePatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pandit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPanditUpdatePatch(apiPanditUpdatePatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PanditsApi.apiPanditUpdatePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PanditsApi - factory interface
 */
export const PanditsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PanditsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new pandit
         * @param {ApiPanditCreatePostRequest} apiPanditCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPanditCreatePost(apiPanditCreatePostRequest: ApiPanditCreatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Pandit> {
            return localVarFp.apiPanditCreatePost(apiPanditCreatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a pandit
         * @param {ApiPanditDeleteDeleteRequest} apiPanditDeleteDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPanditDeleteDelete(apiPanditDeleteDeleteRequest: ApiPanditDeleteDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<Pandit> {
            return localVarFp.apiPanditDeleteDelete(apiPanditDeleteDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all pandits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPanditGetGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Pandit>> {
            return localVarFp.apiPanditGetGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get pandits by temple ID
         * @param {string} templeId Temple ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPanditGetbytempleGet(templeId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Pandit>> {
            return localVarFp.apiPanditGetbytempleGet(templeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a pandit
         * @param {ApiPanditUpdatePatchRequest} apiPanditUpdatePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPanditUpdatePatch(apiPanditUpdatePatchRequest: ApiPanditUpdatePatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<Pandit> {
            return localVarFp.apiPanditUpdatePatch(apiPanditUpdatePatchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PanditsApi - object-oriented interface
 */
export class PanditsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new pandit
     * @param {ApiPanditCreatePostRequest} apiPanditCreatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiPanditCreatePost(apiPanditCreatePostRequest: ApiPanditCreatePostRequest, options?: RawAxiosRequestConfig) {
        return PanditsApiFp(this.configuration).apiPanditCreatePost(apiPanditCreatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a pandit
     * @param {ApiPanditDeleteDeleteRequest} apiPanditDeleteDeleteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiPanditDeleteDelete(apiPanditDeleteDeleteRequest: ApiPanditDeleteDeleteRequest, options?: RawAxiosRequestConfig) {
        return PanditsApiFp(this.configuration).apiPanditDeleteDelete(apiPanditDeleteDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all pandits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiPanditGetGet(options?: RawAxiosRequestConfig) {
        return PanditsApiFp(this.configuration).apiPanditGetGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get pandits by temple ID
     * @param {string} templeId Temple ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiPanditGetbytempleGet(templeId: string, options?: RawAxiosRequestConfig) {
        return PanditsApiFp(this.configuration).apiPanditGetbytempleGet(templeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a pandit
     * @param {ApiPanditUpdatePatchRequest} apiPanditUpdatePatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiPanditUpdatePatch(apiPanditUpdatePatchRequest: ApiPanditUpdatePatchRequest, options?: RawAxiosRequestConfig) {
        return PanditsApiFp(this.configuration).apiPanditUpdatePatch(apiPanditUpdatePatchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileApi - axios parameter creator
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProfileProfileGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/profile/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user profile
         * @param {string} userId User ID
         * @param {ApiProfileProfileUserIdPatchRequest} apiProfileProfileUserIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProfileProfileUserIdPatch: async (userId: string, apiProfileProfileUserIdPatchRequest: ApiProfileProfileUserIdPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiProfileProfileUserIdPatch', 'userId', userId)
            // verify required parameter 'apiProfileProfileUserIdPatchRequest' is not null or undefined
            assertParamExists('apiProfileProfileUserIdPatch', 'apiProfileProfileUserIdPatchRequest', apiProfileProfileUserIdPatchRequest)
            const localVarPath = `/api/profile/profile/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiProfileProfileUserIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiProfileProfileGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiProfileProfileGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.apiProfileProfileGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user profile
         * @param {string} userId User ID
         * @param {ApiProfileProfileUserIdPatchRequest} apiProfileProfileUserIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiProfileProfileUserIdPatch(userId: string, apiProfileProfileUserIdPatchRequest: ApiProfileProfileUserIdPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiProfileProfileUserIdPatch(userId, apiProfileProfileUserIdPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.apiProfileProfileUserIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfileApi - factory interface
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * 
         * @summary Get current user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProfileProfileGet(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.apiProfileProfileGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user profile
         * @param {string} userId User ID
         * @param {ApiProfileProfileUserIdPatchRequest} apiProfileProfileUserIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProfileProfileUserIdPatch(userId: string, apiProfileProfileUserIdPatchRequest: ApiProfileProfileUserIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.apiProfileProfileUserIdPatch(userId, apiProfileProfileUserIdPatchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 */
export class ProfileApi extends BaseAPI {
    /**
     * 
     * @summary Get current user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiProfileProfileGet(options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).apiProfileProfileGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user profile
     * @param {string} userId User ID
     * @param {ApiProfileProfileUserIdPatchRequest} apiProfileProfileUserIdPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiProfileProfileUserIdPatch(userId: string, apiProfileProfileUserIdPatchRequest: ApiProfileProfileUserIdPatchRequest, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).apiProfileProfileUserIdPatch(userId, apiProfileProfileUserIdPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UploadApi - axios parameter creator
 */
export const UploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload multiple images
         * @param {Array<File>} images Array of image files (max 10 files, 5MB each)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUploadMultiplePost: async (images: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'images' is not null or undefined
            assertParamExists('apiUploadMultiplePost', 'images', images)
            const localVarPath = `/api/upload/multiple`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (images) {
                images.forEach((element) => {
                    localVarFormParams.append('images', element as any);
                })
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a single image
         * @param {File} image Image file (max 5MB)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUploadSinglePost: async (image: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'image' is not null or undefined
            assertParamExists('apiUploadSinglePost', 'image', image)
            const localVarPath = `/api/upload/single`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadApi - functional programming interface
 */
export const UploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Upload multiple images
         * @param {Array<File>} images Array of image files (max 10 files, 5MB each)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUploadMultiplePost(images: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUploadMultiplePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUploadMultiplePost(images, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.apiUploadMultiplePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload a single image
         * @param {File} image Image file (max 5MB)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUploadSinglePost(image: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUploadSinglePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUploadSinglePost(image, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.apiUploadSinglePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UploadApi - factory interface
 */
export const UploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadApiFp(configuration)
    return {
        /**
         * 
         * @summary Upload multiple images
         * @param {Array<File>} images Array of image files (max 10 files, 5MB each)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUploadMultiplePost(images: Array<File>, options?: RawAxiosRequestConfig): AxiosPromise<ApiUploadMultiplePost200Response> {
            return localVarFp.apiUploadMultiplePost(images, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a single image
         * @param {File} image Image file (max 5MB)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUploadSinglePost(image: File, options?: RawAxiosRequestConfig): AxiosPromise<ApiUploadSinglePost200Response> {
            return localVarFp.apiUploadSinglePost(image, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadApi - object-oriented interface
 */
export class UploadApi extends BaseAPI {
    /**
     * 
     * @summary Upload multiple images
     * @param {Array<File>} images Array of image files (max 10 files, 5MB each)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiUploadMultiplePost(images: Array<File>, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).apiUploadMultiplePost(images, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a single image
     * @param {File} image Image file (max 5MB)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiUploadSinglePost(image: File, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).apiUploadSinglePost(image, options).then((request) => request(this.axios, this.basePath));
    }
}



